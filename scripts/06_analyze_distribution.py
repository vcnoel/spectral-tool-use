
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import mannwhitneyu
from statsmodels.stats.multitest import multipletests
import argparse
import os

def compute_cohens_d(x, y):
    nx = len(x)
    ny = len(y)
    dof = nx + ny - 2
    return (np.mean(x) - np.mean(y)) / np.sqrt(((nx-1)*np.std(x, ddof=1) ** 2 + (ny-1)*np.std(y, ddof=1) ** 2) / dof)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--input", type=str, required=True, help="Path to sweep results CSV")
    parser.add_argument("--output_dir", type=str, default="figures/", help="Directory to save plots")
    args = parser.parse_args()
    
    os.makedirs(args.output_dir, exist_ok=True)
    
    print(f"Loading data from {args.input}...")
    df = pd.read_csv(args.input)
    
    # Separation
    valid = df[df['is_hallucination'] == 0]
    hallucination = df[df['is_hallucination'] == 1]
    
    print(f"Valid: {len(valid)}, Hallucination: {len(hallucination)}")
    
    metrics = ["HFER", "Fiedler", "Smoothness", "Entropy"]
    n_layers = 32
    
    stats_results = []
    
    for metric in metrics:
        print(f"Analyzing {metric}...")
        
        layer_stats = []
        p_values = []
        
        # 1. Compute Stats per layer
        for layer in range(n_layers):
            col = f"L{layer}_{metric}"
            if col not in df.columns:
                continue
                
            v_data = valid[col].dropna()
            h_data = hallucination[col].dropna()
            
            # Cohen's d
            d = compute_cohens_d(h_data, v_data) # Positive d means Hallucination > Valid
            
            # Mann-Whitney U
            try:
                stat, p = mannwhitneyu(h_data, v_data, alternative='two-sided')
            except:
                p = 1.0
            
            p_values.append(p)
            
            layer_stats.append({
                "layer": layer,
                "metric": metric,
                "mean_valid": np.mean(v_data),
                "std_valid": np.std(v_data),
                "mean_hallucination": np.mean(h_data),
                "std_hallucination": np.std(h_data),
                "cohens_d": d,
                "p_value_raw": p
            })
            
        # 2. BH Correction
        reject, pvals_corrected, _, _ = multipletests(p_values, alpha=0.05, method='fdr_bh')
        
        for i, stat in enumerate(layer_stats):
            stat['p_value_corrected'] = pvals_corrected[i]
            stat['significant'] = reject[i]
            stats_results.append(stat)
            
        # 3. Plotting
        plt.figure(figsize=(12, 6))
        
        layers = [s['layer'] for s in layer_stats]
        mu_v = np.array([s['mean_valid'] for s in layer_stats])
        std_v = np.array([s['std_valid'] for s in layer_stats])
        mu_h = np.array([s['mean_hallucination'] for s in layer_stats])
        std_h = np.array([s['std_hallucination'] for s in layer_stats])
        
        # Valid (Blue)
        plt.plot(layers, mu_v, label='Valid', color='blue', linewidth=2)
        plt.fill_between(layers, mu_v - std_v, mu_v + std_v, color='blue', alpha=0.1)
        
        # Hallucination (Red)
        plt.plot(layers, mu_h, label='Hallucination', color='red', linewidth=2)
        plt.fill_between(layers, mu_h - std_h, mu_h + std_h, color='red', alpha=0.1)
        
        # Significance Markers - REMOVED per user request
        # sig_layers = [s['layer'] for s in layer_stats if s['significant']]
        # if sig_layers:
        #    y_max = max(np.max(mu_v + std_v), np.max(mu_h + std_h))
        #    plt.scatter(sig_layers, [y_max * 1.05] * len(sig_layers), marker='*', color='black', s=50, label='p < 0.05 (BH)')
            
        plt.title(f"{metric} across Layers (N={len(df)})")
        plt.xlabel("Layer Index")
        plt.ylabel(metric)
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        
        # Save PNG and PDF
        out_png = os.path.join(args.output_dir, f"{metric}.png")
        out_pdf = os.path.join(args.output_dir, f"{metric}.pdf")
        
        plt.savefig(out_png, dpi=300)
        plt.savefig(out_pdf, format='pdf')
        print(f"Saved plots to {out_png} and {out_pdf}")
        plt.close()
        
        # Generate TeX
        tex_path = os.path.join(args.output_dir, f"{metric}.tex")
        save_tex(tex_path, metric, layers, mu_v, std_v, mu_h, std_h)
        print(f"Saved TeX to {tex_path}")

def save_tex(path, metric, layers, mu_v, std_v, mu_h, std_h):
    with open(path, 'w') as f:
        f.write("% PGFPlots code generated by Spectral Glaive\n")
        f.write("\\begin{tikzpicture}\n")
        f.write(f"\\begin{{axis}}[\n")
        f.write(f"    title={{{metric}}},\n")
        f.write(f"    xlabel={{Layer}},\n")
        f.write(f"    ylabel={{{metric}}},\n")
        f.write(f"    grid=major,\n")
        f.write(f"    width=10cm,\n")
        f.write(f"    height=6cm,\n")
        f.write(f"    legend pos=north west\n")
        f.write("]\n\n")
        
        # Valid
        f.write("% Valid (Blue)\n")
        coords_v = " ".join([f"({x},{y:.4f})" for x, y in zip(layers, mu_v)])
        f.write(f"\\addplot[color=blue, thick, mark=none] coordinates {{ {coords_v} }};\n")
        f.write("\\addlegendentry{Valid}\n")
        
        # Valid Error Band (simplified as upper/lower lines for compatibility, fill is complex in raw tex without preamble)
        # Actually, let's just do lines for bounds or omit for cleanliness if 'highest quality' mainly means the lines?
        # User usually wants error bands. Let's try to do a simple `name path` approach if the user has pgfplots >= 1.10
        # We will just write the coordinates for mean +/- std
        
        coords_v_upper = " ".join([f"({x},{y+s:.4f})" for x, y, s in zip(layers, mu_v, std_v)])
        coords_v_lower = " ".join([f"({x},{y-s:.4f})" for x, y, s in zip(layers, mu_v, std_v)])
        
        f.write(f"\\addplot[name path=v_top, color=blue, opacity=0.1, forget plot] coordinates {{ {coords_v_upper} }};\n")
        f.write(f"\\addplot[name path=v_bot, color=blue, opacity=0.1, forget plot] coordinates {{ {coords_v_lower} }};\n")
        f.write(f"\\addplot[blue, opacity=0.1] fill between[of=v_top and v_bot];\n\n")

        # Hallucination
        f.write("% Hallucination (Red)\n")
        coords_h = " ".join([f"({x},{y:.4f})" for x, y in zip(layers, mu_h)])
        f.write(f"\\addplot[color=red, thick, mark=none] coordinates {{ {coords_h} }};\n")
        f.write("\\addlegendentry{Hallucination}\n")
        
        coords_h_upper = " ".join([f"({x},{y+s:.4f})" for x, y, s in zip(layers, mu_h, std_h)])
        coords_h_lower = " ".join([f"({x},{y-s:.4f})" for x, y, s in zip(layers, mu_h, std_h)])
        
        f.write(f"\\addplot[name path=h_top, color=red, opacity=0.1, forget plot] coordinates {{ {coords_h_upper} }};\n")
        f.write(f"\\addplot[name path=h_bot, color=red, opacity=0.1, forget plot] coordinates {{ {coords_h_lower} }};\n")
        f.write(f"\\addplot[red, opacity=0.1] fill between[of=h_top and h_bot];\n")
        
        f.write("\\end{axis}\n")
        f.write("\\end{tikzpicture}\n")

if __name__ == "__main__":
    main()
